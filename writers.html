<!DOCTYPE html><html lang="en"><head><title>writers</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="writers"><meta name="groc-project-path" content="writers.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/writers.go">writers.go</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-writers-log-middleware-"><strong>Writers - Log Middleware</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Package wallaby contains a few different log middlemares which intercept
log writes for different reasons such as buffering the writes.</p>
<p>By default all writes into the log are atomic and are flushed to disk
immediately. Having middleware allows the write strategy to be tweaked.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"os"</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><br/></p>
<h3 id="-middleware-interface-"><em>Middleware Interface</em></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>DecorativeWriteCloser</code> allows for middleware around the internal file writer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> DecorativeWriteCloser <span class="hljs-keyword">func</span>(io.WriteCloser) io.WriteCloser</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-built-in-middleware-"><em>Built-in Middleware</em></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DefaultBufferedWriter is pre-configured middleware with a buffer size of 64KB</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> DefaultBufferedWriter DecorativeWriteCloser = NewBufferedWriter(<span class="hljs-number">65536</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h3 id="-newbufferedwriter-"><strong>NewBufferedWriter</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NewBufferedWriter creates a buffered writer with the given buffer
size. A <code>DecorativeWriteCloser</code> is returned which wraps the log&#39;s
internal <code>io.WriteCloser</code> in a <code>bufio.Writer</code>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewBufferedWriter(size <span class="hljs-typename">int</span>) DecorativeWriteCloser {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(writer io.WriteCloser) io.WriteCloser {
        <span class="hljs-keyword">return</span> bufferedWriteCloser{size, <span class="hljs-number">0</span>, <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">0</span>, size), writer}
    }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><blockquote>
<p>The buffered middleware is implemented as a <code>bufferedWriteCloser</code>
which requires the newly created <code>bufio.Writer</code> as well as the
log&#39;s internal <code>io.WriteCloser</code>.</p>
</blockquote></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> bufferedWriteCloser <span class="hljs-keyword">struct</span> {
    size   <span class="hljs-typename">int</span>
    offset <span class="hljs-typename">int</span>
    buffer []<span class="hljs-typename">byte</span>
    parent io.WriteCloser
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="write">Write</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write writes the data into the buffer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (b bufferedWriteCloser) Write(data []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt; b.size {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrExceedsBufferSize
    }

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)+b.offset &gt; b.size {
        b.parent.Write(b.buffer[:b.offset])

        n = b.offset
        b.offset = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-built_in">copy</span>(b.buffer[:<span class="hljs-built_in">len</span>(data)], data)
    b.offset += <span class="hljs-built_in">len</span>(data)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(data), <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="close">Close</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close flushes the buffer and then closes the parent <code>io.WriteCloser.</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (b bufferedWriteCloser) Close() error {
    <span class="hljs-keyword">if</span> b.offset &gt; <span class="hljs-number">0</span> {
        b.parent.Write(b.buffer[:b.offset])
        b.offset = <span class="hljs-number">0</span>
    }
    <span class="hljs-keyword">return</span> b.parent.Close()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h3 id="-newatomicwriter-"><strong>NewAtomicWriter</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NewAtomicWriter is built-in middleware which wrapps all file writes. Each
write is flushed to disk and a close also closes the underlying file.</p>
<blockquote>
<p>The atomic middleware is implemented as an <code>atomicWriteCloser</code>.</p>
</blockquote></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewAtomicWriter(file *os.File) io.WriteCloser {
    <span class="hljs-keyword">return</span> atomicWriteCloser{file}
}

<span class="hljs-keyword">type</span> atomicWriteCloser <span class="hljs-keyword">struct</span> {
    file *os.File
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="write">Write</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write writes the data into the file and syncs the file to disk. If the
write causes an error it is bubbled up. If the write succeeds, the data is
then synced.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (a atomicWriteCloser) Write(data []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error) {
    n, err = a.file.Write(data)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
    }

    err = a.file.Sync()
    <span class="hljs-keyword">return</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="close">Close</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close syncs the file to disk and then closes the file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (a atomicWriteCloser) Close() error {
    err := a.file.Sync()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-keyword">return</span> a.file.Close()
}</div></div></div></div></body></html>