<!DOCTYPE html><html lang="en"><head><title>writers</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="writers"><meta name="groc-project-path" content="writers.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/writers.go">writers.go</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-writers-log-middleware-"><strong>Writers - Log Middleware</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Writers contains a few different log middlemares which intercept log writes
for different reasons such as buffering the writes.</p>
<p>By default all writes into the log are atomic and are flushed to disk
immediately. Having middleware allows the write strategy to be tweaked.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bufio"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"os"</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><br/></p>
<h3 id="-middleware-interface-"><em>Middleware Interface</em></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>DecorativeWriteCloser</code> allows for middleware around the internal file writer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> DecorativeWriteCloser <span class="hljs-keyword">func</span>(io.WriteCloser) io.WriteCloser</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-built-in-middleware-"><em>Built-in Middleware</em></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li><code>DefaultBufferedWriter</code> is pre-configured middleware with a buffer size of 64KB</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> DefaultBufferedWriter DecorativeWriteCloser = NewBufferedWriter(<span class="hljs-number">65536</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h3 id="-newbufferedwriter-"><strong>NewBufferedWriter</strong></h3>
<p><code>NewBufferedWriter</code> creates a buffered writer with the given buffer
size. A <code>DecorativeWriteCloser</code> is returned which wraps the log&#39;s
internal <code>io.WriteCloser</code> in a <code>bufio.Writer</code>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewBufferedWriter(size <span class="hljs-typename">int</span>) DecorativeWriteCloser {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(writer io.WriteCloser) io.WriteCloser {
        <span class="hljs-keyword">return</span> bufferedWriteCloser{bufio.NewWriterSize(writer, size), writer}
    }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><blockquote>
<p>The buffered middleware is implemented as a <code>bufferedWriteCloser</code>
which requires the newly created <code>bufio.Writer</code> as well as the
log&#39;s internal <code>io.WriteCloser</code>.</p>
</blockquote></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> bufferedWriteCloser <span class="hljs-keyword">struct</span> {
    writer *bufio.Writer
    parent io.WriteCloser
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="write">Write</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Write</code> writes the data into the buffer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (b bufferedWriteCloser) Write(data []<span class="hljs-typename">byte</span>) (<span class="hljs-typename">int</span>, error) {
    <span class="hljs-keyword">return</span> b.writer.Write(data)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="close">Close</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Close</code> flushes the buffer and then closes the parent <code>io.WriteCloser.</code></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (b bufferedWriteCloser) Close() error {
    err := b.writer.Flush()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-keyword">return</span> b.parent.Close()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h3 id="-newatomicwriter-"><strong>NewAtomicWriter</strong></h3>
<p><code>NewAtomicWriter</code> is built-in middleware which wrapps all file writes. Each
write is flushed to disk and a close also closes the underlying file.</p>
<blockquote>
<p>The atomic middleware is implemented as an <code>atomicWriteCloser</code>.</p>
</blockquote></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewAtomicWriter(file *os.File) io.WriteCloser {
    <span class="hljs-keyword">return</span> atomicWriteCloser{file}
}

<span class="hljs-keyword">type</span> atomicWriteCloser <span class="hljs-keyword">struct</span> {
    file *os.File
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="write">Write</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Write</code> writes the data into the file and syncs the file to disk. If the
write causes an error it is bubbled up. If the write succeeds, the data is
then synced.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (a atomicWriteCloser) Write(data []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error) {
    n, err = a.file.Write(data)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
    }

    err = a.file.Sync()
    <span class="hljs-keyword">return</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="close">Close</h4></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Close</code> syncs the file to disk and then closes the file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (a atomicWriteCloser) Close() error {
    err := a.file.Sync()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-keyword">return</span> a.file.Close()
}</div></div></div></div></body></html>