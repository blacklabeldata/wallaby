<!DOCTYPE html><html lang="en"><head><title>log_index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="log_index"><meta name="groc-project-path" content="log_index.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/log_index.go">log_index.go</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"bufio"</span>
	<span class="hljs-string">"io"</span>
	<span class="hljs-string">"os"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"github.com/eliquious/xbinary"</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IndexFactory creates an index. The reason for this is solely for future growth... perhaps a bit premature. The main reason is for future versions of log files or different backing stores.
type IndexFactory interface {
    GetOrCreateIndex(flags uint32) (*LogIndex, error)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">// </span>
<span class="hljs-keyword">type</span> IndexFactory <span class="hljs-keyword">func</span>(filename <span class="hljs-typename">string</span>, version <span class="hljs-typename">uint8</span>, flags <span class="hljs-typename">uint32</span>) (LogIndex, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogIndex maintains a list of all the records in the log file. IndexRecords</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogIndex <span class="hljs-keyword">interface</span> {
	io.WriteCloser

	Size() <span class="hljs-typename">uint64</span>
	Header() FileHeader
	Slice(offset <span class="hljs-typename">int64</span>, limit <span class="hljs-typename">int64</span>) (IndexSlice, error)
	Flush() error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FileHeader describes which version the file was written with. Flags
represents boolean flags.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> FileHeader <span class="hljs-keyword">interface</span> {
	Version() <span class="hljs-typename">uint8</span>
	Flags() <span class="hljs-typename">uint32</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IndexSlice contains several buffered index records for fast access.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> IndexSlice <span class="hljs-keyword">interface</span> {
	Get(index <span class="hljs-typename">int</span>) (IndexRecord, error)
	Size() <span class="hljs-typename">int</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IndexRecord describes each item in an index file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> IndexRecord <span class="hljs-keyword">interface</span> {
	Time() <span class="hljs-typename">int64</span>
	Index() <span class="hljs-typename">uint64</span>
	Offset() <span class="hljs-typename">int64</span>
	TimeToLive() <span class="hljs-typename">int64</span>
	IsExpired() <span class="hljs-typename">bool</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BasicIndexRecord implements the bare IndexRecord interface.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> BasicIndexRecord <span class="hljs-keyword">struct</span> {
	nanos  <span class="hljs-typename">int64</span>
	index  <span class="hljs-typename">uint64</span>
	offset <span class="hljs-typename">int64</span>
	ttl    <span class="hljs-typename">int64</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IndexRecordEncoder writes an <code>IndexRecord</code> into a byte array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> IndexRecordEncoder <span class="hljs-keyword">interface</span> {
	Encode(record IndexRecord) []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IndexRecordDecoder reads an <code>IndexRecord</code> from a bute array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> IndexRecordDecoder <span class="hljs-keyword">interface</span> {
	Decode(data []<span class="hljs-typename">byte</span>) (IndexRecord, error)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time returns when the record was written to the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicIndexRecord) Time() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> i.nanos
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index is a record&#39;s numerical id.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicIndexRecord) Index() <span class="hljs-typename">uint64</span> {
	<span class="hljs-keyword">return</span> i.index
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Offset is the distance the data record is from the start of the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicIndexRecord) Offset() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> i.offset
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TimeToLive allows for records to expire after a period of time. TTL is in
seconds.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicIndexRecord) TimeToLive() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> i.ttl
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IsExpired is a helper function for the index record which returns <code>true</code> if
the current time is beyond the expiration time. The expiration time is
calculated as written time + TTL.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicIndexRecord) IsExpired() <span class="hljs-typename">bool</span> {
	<span class="hljs-keyword">return</span> time.Now().After(time.Unix(i.nanos, <span class="hljs-number">0</span>).Add(time.Duration(i.ttl)))
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BasicFileHeader is the simplest implementation of the FileHeader interface.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> BasicFileHeader <span class="hljs-keyword">struct</span> {
	version <span class="hljs-typename">uint8</span>
	flags   <span class="hljs-typename">uint32</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Version returns the file version.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicFileHeader) Version() <span class="hljs-typename">uint8</span> {
	<span class="hljs-keyword">return</span> i.version
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns the boolean flags for the file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i BasicFileHeader) Flags() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> i.flags
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NewIndexRecordEncoder writes an <code>IndexRecord</code> into a byte array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewIndexRecordEncoder() IndexRecordEncoder {
	<span class="hljs-keyword">return</span> &amp;indexRecordEncoder{<span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">32</span>)}
}

<span class="hljs-keyword">type</span> indexRecordEncoder <span class="hljs-keyword">struct</span> {
	buffer []<span class="hljs-typename">byte</span>
}

<span class="hljs-keyword">func</span> (i *indexRecordEncoder) Encode(record IndexRecord) []<span class="hljs-typename">byte</span> {
	xbinary.LittleEndian.PutInt64(i.buffer, <span class="hljs-number">0</span>, record.Time())
	xbinary.LittleEndian.PutUint64(i.buffer, <span class="hljs-number">8</span>, record.Index())
	xbinary.LittleEndian.PutInt64(i.buffer, <span class="hljs-number">16</span>, record.Offset())
	xbinary.LittleEndian.PutInt64(i.buffer, <span class="hljs-number">24</span>, record.TimeToLive())
	<span class="hljs-keyword">return</span> i.buffer
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NewIndexRecordDecoder creates an <code>IndexRecord</code> decoder which decodes byte
arrays and returns the IndexRecord. An <code>ErrInvalidRecordSize</code> is returned if
the record cannot be read.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> NewIndexRecordDecoder() IndexRecordDecoder {
	<span class="hljs-keyword">return</span> &amp;indexRecordDecoder{}
}

<span class="hljs-keyword">type</span> indexRecordDecoder <span class="hljs-keyword">struct</span> {
}

<span class="hljs-keyword">func</span> (i *indexRecordDecoder) Decode(record []<span class="hljs-typename">byte</span>) (IndexRecord, error) {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(record) != <span class="hljs-number">32</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidRecordSize
	}
	<span class="hljs-keyword">return</span> versionOneIndexRecord{&amp;record, <span class="hljs-number">0</span>}, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>versionOneIndexRecord implements the bare IndexRecord interface.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> versionOneIndexRecord <span class="hljs-keyword">struct</span> {
	buffer *[]<span class="hljs-typename">byte</span>
	offset <span class="hljs-typename">int</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time returns when the record was written to the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i versionOneIndexRecord) Time() <span class="hljs-typename">int64</span> {
	nanos, err := xbinary.LittleEndian.Int64(*i.buffer, <span class="hljs-number">0</span>+i.offset)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		nanos = <span class="hljs-number">0</span>
	}

	<span class="hljs-keyword">return</span> nanos
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index is a record&#39;s numerical id.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i versionOneIndexRecord) Index() <span class="hljs-typename">uint64</span> {
	index, err := xbinary.LittleEndian.Uint64(*i.buffer, <span class="hljs-number">8</span>+i.offset)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		index = <span class="hljs-number">0</span>
	}

	<span class="hljs-keyword">return</span> index
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Offset is the distance the data record is from the start of the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i versionOneIndexRecord) Offset() <span class="hljs-typename">int64</span> {
	offset, err := xbinary.LittleEndian.Int64(*i.buffer, <span class="hljs-number">16</span>+i.offset)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		offset = <span class="hljs-number">0</span>
	}

	<span class="hljs-keyword">return</span> offset
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TimeToLive allows for records to expire after a period of time. TTL is in
seconds.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i versionOneIndexRecord) TimeToLive() <span class="hljs-typename">int64</span> {
	ttl, err := xbinary.LittleEndian.Int64(*i.buffer, <span class="hljs-number">24</span>+i.offset)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		ttl = <span class="hljs-number">0</span>
	}

	<span class="hljs-keyword">return</span> ttl
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IsExpired is a helper function for the index record which returns <code>true</code> if
the current time is beyond the expiration time. The expiration time is
calculated as written time + TTL.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i versionOneIndexRecord) IsExpired() <span class="hljs-typename">bool</span> {
	<span class="hljs-keyword">return</span> time.Now().UnixNano() &gt; i.Time()+i.TimeToLive()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>GetOrCreateIndex either creates a new file or reads from an existing index
file.</p>
<p>VersionOneLogHeader starts with a 3-byte string, &quot;IDX&quot;, followed by an 8-bit
version. After the version, a uint32 represents the boolean flags.
The records start immediately following the bit flags.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> VersionOneIndexFactory(filename <span class="hljs-typename">string</span>, version <span class="hljs-typename">uint8</span>, flags <span class="hljs-typename">uint32</span>) (LogIndex, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>try to open index file, return error on fail</p></div></div><div class="code"><div class="wrapper">	file, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="hljs-number">0600</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get file stat, close file and return on error</p></div></div><div class="code"><div class="wrapper">	stat, err := file.Stat()
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		file.Close()
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get header, close file and return on error</p></div></div><div class="code"><div class="wrapper">	buf := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexHeaderSize)
	<span class="hljs-keyword">var</span> header BasicFileHeader
	<span class="hljs-keyword">var</span> size <span class="hljs-typename">uint64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if file already has header</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> stat.Size() &gt;= VersionOneIndexHeaderSize {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read file header, close and return upon error</p></div></div><div class="code"><div class="wrapper">		n, err := file.ReadAt(buf, <span class="hljs-number">0</span>)
		<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
			file.Close()
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>failed to read entire header</p></div></div><div class="code"><div class="wrapper">		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n != VersionOneIndexHeaderSize {
			file.Close()
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrReadIndexHeader
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read flags</p></div></div><div class="code"><div class="wrapper">		flags, err := xbinary.LittleEndian.Uint32(buf, <span class="hljs-number">4</span>)
		<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
			file.Close()
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header</p></div></div><div class="code"><div class="wrapper">		header = BasicFileHeader{flags: flags, version: buf[<span class="hljs-number">3</span>]}

		size = (<span class="hljs-typename">uint64</span>(stat.Size()) - <span class="hljs-typename">uint64</span>(VersionOneIndexHeaderSize)) / <span class="hljs-typename">uint64</span>(VersionOneIndexRecordSize)
	} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write magic string</p></div></div><div class="code"><div class="wrapper">		xbinary.LittleEndian.PutString(buf, <span class="hljs-number">0</span>, <span class="hljs-typename">string</span>(IndexFileSignature))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write version</p></div></div><div class="code"><div class="wrapper">		buf[<span class="hljs-number">3</span>] = <span class="hljs-typename">byte</span>(VersionOne)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write boolean flags</p></div></div><div class="code"><div class="wrapper">		xbinary.LittleEndian.PutUint32(buf, <span class="hljs-number">4</span>, flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write index header to file</p></div></div><div class="code"><div class="wrapper">		_, err := file.Write(buf)
		<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
			file.Close()
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>flush data to disk</p></div></div><div class="code"><div class="wrapper">		err = file.Sync()
		<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteIndexHeader
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create index header</p></div></div><div class="code"><div class="wrapper">		header = BasicFileHeader{VersionOne, flags}

	}

	writer := bufio.NewWriterSize(file, <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)
	idx := VersionOneIndexFile{
		fd:     file,
		writer: writer,
		header: header,
		extbuf: xbinary.LittleEndian,
		size:   size,
		buffer: <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexRecordSize)}
	<span class="hljs-keyword">return</span> &amp;idx, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneIndexFile implements the IndexFile interface and is created by VersionOneIndexFactory.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> VersionOneIndexFile <span class="hljs-keyword">struct</span> {
	fd     *os.File
	writer *bufio.Writer
	header BasicFileHeader
	extbuf xbinary.ExtendedBuffer
	size   <span class="hljs-typename">uint64</span>
	buffer []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flush writes any buffered data onto permanant storage.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) Flush() error {
	i.writer.Flush()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>sync changes to disk</p></div></div><div class="code"><div class="wrapper">	err := i.fd.Sync()
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close flushed the index with permanant storage and closes the index.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) Close() error {
	err := i.Flush()
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> err
	}

	<span class="hljs-keyword">return</span> i.fd.Close()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Append adds an index record to the end of the index file. V1 index records have a time, an index and an offset in the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) Write(record []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write index buffer to file</p></div></div><div class="code"><div class="wrapper">	n, err = i.writer.Write(record)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> n, err
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>increment index size</p></div></div><div class="code"><div class="wrapper">	i.incrementSize()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return num bytes and nil error</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IncrementSize bumps the index size by one.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) incrementSize() {
	i.size++
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size is the number of elements in the index. Which should coorespond with the number of records in the data file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) Size() <span class="hljs-typename">uint64</span> {
	<span class="hljs-keyword">return</span> i.size
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Header returns the file header which describes the index file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i VersionOneIndexFile) Header() FileHeader {
	<span class="hljs-keyword">return</span> i.header
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Slice returns multiple index records starting at the given offset.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (i *VersionOneIndexFile) Slice(offset <span class="hljs-typename">int64</span>, limit <span class="hljs-typename">int64</span>) (IndexSlice, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>offset too  or less than 0</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> offset &gt; <span class="hljs-typename">int64</span>(i.size) || offset &lt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrSliceOutOfBounds</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>invalid limit</p></div></div><div class="code"><div class="wrapper">	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> limit &lt; <span class="hljs-number">1</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrSliceOutOfBounds
	}

	<span class="hljs-keyword">var</span> buf []<span class="hljs-typename">byte</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>requested slice too large</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> limit &gt; MaximumIndexSlice {
		buf = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexRecordSize*MaximumIndexSlice)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>request exceeds index size</p></div></div><div class="code"><div class="wrapper">	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-typename">uint64</span>(offset+limit) &gt; i.size {
		buf = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexRecordSize*(<span class="hljs-typename">uint64</span>(offset+limit)-(i.size)))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>full request can be satisfied</p></div></div><div class="code"><div class="wrapper">	} <span class="hljs-keyword">else</span> {
		buf = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexRecordSize*limit)
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read records into buffer</p></div></div><div class="code"><div class="wrapper">	read, err := i.fd.ReadAt(buf, <span class="hljs-typename">int64</span>(offset*VersionOneIndexRecordSize)+VersionOneIndexHeaderSize)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrReadIndex
	}

	<span class="hljs-keyword">return</span> VersionOneIndexSlice{buf, read / VersionOneIndexRecordSize}, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneIndexSlice provides for retrieval of buffered index records</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> VersionOneIndexSlice <span class="hljs-keyword">struct</span> {
	buffer []<span class="hljs-typename">byte</span>
	size   <span class="hljs-typename">int</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the number of records in this slice.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (s VersionOneIndexSlice) Size() <span class="hljs-typename">int</span> {
	<span class="hljs-keyword">return</span> s.size
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get returns a particular index record. ErrSliceOutOfBounds is returned is the record index given is &lt; 0 or greater than the size of the slice.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (s VersionOneIndexSlice) Get(index <span class="hljs-typename">int</span>) (IndexRecord, error) {
	<span class="hljs-keyword">if</span> index &gt; s.size || index &lt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrSliceOutOfBounds
	}

	<span class="hljs-keyword">return</span> versionOneIndexRecord{&amp;s.buffer, index * VersionOneIndexRecordSize}, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (s VersionOneIndexSlice) MarshalBinary() (data []<span class="hljs-typename">byte</span>, err error) {
	<span class="hljs-keyword">return</span> s.buffer, <span class="hljs-constant">nil</span>
}</div></div></div></div></body></html>