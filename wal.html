<!DOCTYPE html><html lang="en"><head><title>wal</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="wal"><meta name="groc-project-path" content="wal.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/wal.go">wal.go</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"sync"</span>
    <span class="hljs-string">"time"</span>
)
<span class="hljs-keyword">import</span> <span class="hljs-string">"os"</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"errors"</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"github.com/eliquious/xbinary"</span>

<span class="hljs-keyword">var</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrReadIndexHeader occurs when the index header cannot be read</p></div></div><div class="code"><div class="wrapper">    ErrReadIndexHeader = errors.New(<span class="hljs-string">"failed to read index header"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrWriteIndexHeader occurs when the index header cannot be written</p></div></div><div class="code"><div class="wrapper">    ErrWriteIndexHeader = errors.New(<span class="hljs-string">"failed to write index header"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrReadLogHeader occurs when the log header cannot be read</p></div></div><div class="code"><div class="wrapper">    ErrReadLogHeader = errors.New(<span class="hljs-string">"failed to read log header"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrWriteLogHeader occurs when the log header cannot be written</p></div></div><div class="code"><div class="wrapper">    ErrWriteLogHeader = errors.New(<span class="hljs-string">"failed to write log header"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrSliceOutOfBounds occurs when index.Slice is called and the offset is larger than the size of the index.</p></div></div><div class="code"><div class="wrapper">    ErrSliceOutOfBounds = errors.New(<span class="hljs-string">"read offset out of bounds"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrReadIndex occurs when index.Slice fails to read the records</p></div></div><div class="code"><div class="wrapper">    ErrReadIndex = errors.New(<span class="hljs-string">"failed to read index records"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrConfigRequired occurs when no log config is given when creating or opening a log file.</p></div></div><div class="code"><div class="wrapper">    ErrConfigRequired = errors.New(<span class="hljs-string">"log config required"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrInvalidFileVersion occurs when the version in the file header is unrecognized.</p></div></div><div class="code"><div class="wrapper">    ErrInvalidFileVersion = errors.New(<span class="hljs-string">"invalid file version"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ErrWriteLogRecord occurs when a record fails to be written to the log</p></div></div><div class="code"><div class="wrapper">    ErrWriteLogRecord = errors.New(<span class="hljs-string">"failed to write record"</span>)
)

<span class="hljs-keyword">const</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FlagsDefault is the default boolean flags for an index file</p></div></div><div class="code"><div class="wrapper">    DefaultIndexFlags = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOne is an integer denoting the first version</p></div></div><div class="code"><div class="wrapper">    VersionOne                = <span class="hljs-number">1</span>
    VersionOneIndexHeaderSize = <span class="hljs-number">4</span>
    VersionOneIndexRecordSize = <span class="hljs-number">24</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneLogHeaderSize is the header size of version 1 log files</p></div></div><div class="code"><div class="wrapper">    VersionOneLogHeaderSize = <span class="hljs-number">8</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MaximumIndexSlice is the maximum number of index records to be read at one time</p></div></div><div class="code"><div class="wrapper">    MaximumIndexSlice = <span class="hljs-number">32000</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HeaderOffset is the minimum number of bytes in the file before version headers begin.</p></div></div><div class="code"><div class="wrapper">    HeaderOffset = <span class="hljs-number">4</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot captures a specific state of the log. It consists of the time the snapshot was taken, the number of items in the log, and a CRC64 of all the log entries.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Snapshot <span class="hljs-keyword">interface</span> {
    Time() time.Time
    Size() <span class="hljs-typename">uint64</span>
    Hash() <span class="hljs-typename">uint64</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata simply contains descriptive information aboutt the log</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Metadata <span class="hljs-keyword">struct</span> {
    Size             <span class="hljs-typename">int64</span>
    LastModifiedTime <span class="hljs-typename">int64</span>
    FileName         <span class="hljs-typename">string</span>
    IndexFileName    <span class="hljs-typename">string</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Config stores several log settings.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> {
    FileMode      os.FileMode
    MaxRecordSize <span class="hljs-typename">int</span>
    Flags         <span class="hljs-typename">uint32</span>
    Version       <span class="hljs-typename">uint8</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DefaultConfig will be used if the given config is nil.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> DefaultConfig Config = Config{
    FileMode:      <span class="hljs-number">0600</span>,
    MaxRecordSize: DefaultMaxRecordSize,
    Flags:         DefaultRecordFlags,
    Version:       VersionOne,
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> createVersionOne(file *os.File, filename <span class="hljs-typename">string</span>, config Config) (WriteAheadLog, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create boolean flags</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> flags <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read file size</p></div></div><div class="code"><div class="wrapper">    stat, err := file.Stat()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }
    size := stat.Size()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header buf</p></div></div><div class="code"><div class="wrapper">    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, VersionOneIndexHeaderSize)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>determine if it&#39;s a new file or not
By this point, the file is gauranteed to have at least 4 bytes.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> size &gt; HeaderOffset {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read file header, close and return upon error</p></div></div><div class="code"><div class="wrapper">        _, err := file.ReadAt(buf, HeaderOffset)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            file.Close()
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read flags</p></div></div><div class="code"><div class="wrapper">        f, err := xbinary.LittleEndian.Uint32(buf, VersionOneIndexHeaderSize)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            file.Close()
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
        }
        flags = f
    } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write boolean flags into header buffer</p></div></div><div class="code"><div class="wrapper">        xbinary.LittleEndian.PutUint32(buf, <span class="hljs-number">0</span>, config.Flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write version header to file</p></div></div><div class="code"><div class="wrapper">        _, err := file.Write(buf)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            file.Close()
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>flush data to disk</p></div></div><div class="code"><div class="wrapper">        err = file.Sync()
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteLogHeader
        }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header</p></div></div><div class="code"><div class="wrapper">    header := BasicFileHeader{flags: flags, version: VersionOne}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create version one log file</p></div></div><div class="code"><div class="wrapper">    factory := VersionOneIndexFactory{filename + <span class="hljs-string">".idx"</span>}
    record_factory := VersionOneLogRecordFactory{config.MaxRecordSize}
    index, err := factory.GetOrCreateIndex(DefaultIndexFlags)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        file.Close()
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }

    <span class="hljs-keyword">var</span> lock sync.Mutex
    log := &amp;VersionOneLogFile{lock, file, file, &amp;header, index, record_factory, config.Flags, <span class="hljs-typename">int64</span>(size), CLOSED}

    <span class="hljs-keyword">return</span> log, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> New(filename <span class="hljs-typename">string</span>, config Config) (WriteAheadLog, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return error if config is nil</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> &amp;config == <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrConfigRequired
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>try to open log file, return error on fail</p></div></div><div class="code"><div class="wrapper">    file, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_RDWR, config.FileMode)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get file stat, close file and return on error</p></div></div><div class="code"><div class="wrapper">    stat, err := file.Stat()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        file.Close()
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get header, close file and return on error</p></div></div><div class="code"><div class="wrapper">    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">4</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header and log
var header BasicFileHeader</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> log WriteAheadLog</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if file already has header</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> stat.Size() &gt;= HeaderOffset {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read file header, close and return upon error</p></div></div><div class="code"><div class="wrapper">        _, err := file.ReadAt(buf, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            file.Close()
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read version</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">switch</span> buf[<span class="hljs-number">3</span>] {
        <span class="hljs-keyword">case</span> VersionOne:

            <span class="hljs-keyword">return</span> createVersionOne(file, filename, config)

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidFileVersion
        }
    } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write magic string</p></div></div><div class="code"><div class="wrapper">        xbinary.LittleEndian.PutString(buf, <span class="hljs-number">0</span>, <span class="hljs-string">"LOG"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write version</p></div></div><div class="code"><div class="wrapper">        buf[<span class="hljs-number">3</span>] = <span class="hljs-typename">byte</span>(VersionOne)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write index header to file</p></div></div><div class="code"><div class="wrapper">        _, err := file.Write(buf)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            file.Close()
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>flush data to disk</p></div></div><div class="code"><div class="wrapper">        err = file.Sync()
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteLogHeader
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create new log file</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">switch</span> config.Version {
        <span class="hljs-keyword">case</span> VersionOne:

            <span class="hljs-keyword">return</span> createVersionOne(file, filename, config)

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidFileVersion
        }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return log file</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> log, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneLogFile</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> VersionOneLogFile <span class="hljs-keyword">struct</span> {
    lock        sync.Mutex
    fd          *os.File
    writeCloser io.WriteCloser
    header      FileHeader
    index       LogIndex
    factory     VersionOneLogRecordFactory
    flags       <span class="hljs-typename">uint32</span>
    size        <span class="hljs-typename">int64</span>
    state       State
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Open() error {
    v.state = OPEN
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create cursor</p></div></div><div class="code"><div class="wrapper">    cur := v.Cursor()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>iterate over requested record range</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> record, err := cur.Seek(offset); err != <span class="hljs-constant">nil</span> &amp;&amp; record.Index() &lt; limit+offset; record, err = cur.Next() {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>marshal record into a buffer</p></div></div><div class="code"><div class="wrapper">        data, e := record.MarshalBinary()
        <span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
            <span class="hljs-keyword">return</span> e
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write data</p></div></div><div class="code"><div class="wrapper">        _, e = writer.Write(data)
        <span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
            <span class="hljs-keyword">return</span> e
        }
    }

    <span class="hljs-keyword">return</span> cur.Close()
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) State() State {
    <span class="hljs-keyword">return</span> v.state
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Use(writers ...DecorativeWriteCloser) {
    <span class="hljs-keyword">if</span> v.state == CLOSED {
        <span class="hljs-keyword">for</span> _, writer := <span class="hljs-keyword">range</span> writers {
            v.writeCloser = writer(v.writeCloser)
        }
    }
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Append(data []<span class="hljs-typename">byte</span>) (LogRecord, error) {
    index, err := v.index.Size()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteLogRecord
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create log record</p></div></div><div class="code"><div class="wrapper">    record, err := v.factory.NewRecord(time.Now().UnixNano(), index, v.flags, data)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteLogRecord
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>binary record</p></div></div><div class="code"><div class="wrapper">    buffer, err := record.MarshalBinary()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>v.fd.Write()</p></div></div><div class="code"><div class="wrapper">    _, err = v.fd.Write(buffer)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }

    v.size += <span class="hljs-typename">int64</span>(<span class="hljs-built_in">len</span>(buffer))
    v.index.Append(BasicIndexRecord{record.Time(), record.Index(), <span class="hljs-typename">int64</span>(v.size)})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return newly created record</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> record, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Cursor() Cursor {
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Snapshot() (Snapshot, error) {
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Metadata() (Metadata, error) {
    meta := Metadata{}
    <span class="hljs-keyword">return</span> meta, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (v *VersionOneLogFile) Recover() error {
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close closes the underlying file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *VersionOneLogFile) Close() error {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set state as CLOSED</p></div></div><div class="code"><div class="wrapper">    v.state = CLOSED</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>sync any last changes to disk</p></div></div><div class="code"><div class="wrapper">    err := v.fd.Sync()
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> err
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>close file handle</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> v.fd.Close()
}</div></div></div></div></body></html>