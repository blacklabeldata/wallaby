<!DOCTYPE html><html lang="en"><head><title>log</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="log"><meta name="groc-project-path" content="log.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/log.go">log.go</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="log-implementations">Log Implementations</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding"</span>
	<span class="hljs-string">"hash"</span>
	<span class="hljs-string">"io"</span>
	<span class="hljs-string">"os"</span>
	<span class="hljs-string">"sync"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"github.com/eliquious/xbinary"</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-log-state-"><strong>Log State</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State is used to maintain the current status of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> State <span class="hljs-typename">uint8</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>CLOSED</code> represents a closed log file</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> CLOSED State = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>OPEN</code> signifies the log is currently open</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> OPEN State = <span class="hljs-number">1</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><br/></p>
<h2 id="-log-interfaces-"><strong>Log Interfaces</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-write-ahead-log-"><strong>Write Ahead Log</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>WriteAheadLog implements an immutable write-ahead log file with indexes and
snapshots.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> WriteAheadLog <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-state-"><em>State</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>State</code> returns the current state of the log file.</p></div></div><div class="code"><div class="wrapper">	State() State</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-open-"><em>Open</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Open</code> opens the log for appending. Prior to this call the log state
should be CLOSED. Once this is called State() should return OPEN.</p></div></div><div class="code"><div class="wrapper">	Open() error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-close-"><em>Close</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Close</code> allows the log to be closed. After this is called, <code>State</code>
should return <code>CLOSED</code> and future appends should fail.</p></div></div><div class="code"><div class="wrapper">	Close() error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-append-"><em>Append</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Append</code> wraps the given bytes array in a Record and returns the record
index or an error</p></div></div><div class="code"><div class="wrapper">	Append(data []<span class="hljs-typename">byte</span>) (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-recover-"><em>Recover</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recover should be called when the log is opened to verify consistency
of the log.</p></div></div><div class="code"><div class="wrapper">	Recover() error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-cursor-"><em>Cursor</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new Cursor initialized at index 0</p></div></div><div class="code"><div class="wrapper">	Cursor() LogCursor</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-use-"><em>Use</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use provides middleware for the internal <code>io.WriteCloser</code></p></div></div><div class="code"><div class="wrapper">	Use(...DecorativeWriteCloser)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-pipe-"><em>Pipe</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pipe copies the raw byte stream into the given <code>io.Writer</code> starting at a
record offset and reading up until the given limit.</p></div></div><div class="code"><div class="wrapper">	Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-snapshot-"><em>Snapshot</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot records the current position of the log file.</p></div></div><div class="code"><div class="wrapper">	Snapshot() (Snapshot, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-metadata-"><em>Metadata</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata returns metadata of the log file.</p></div></div><div class="code"><div class="wrapper">	Metadata() (Metadata, error)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-log-cursor-"><strong>Log Cursor</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogCursor allows for quite navigation through the log. All Cursor start at zero
 and moves forward until EOF.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogCursor <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-seek-"><em>Seek</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek moves the Cursor to the given record index.</p></div></div><div class="code"><div class="wrapper">	Seek(offset <span class="hljs-typename">uint64</span>) (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-next-"><em>Next</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next moves the Cursor forward one record.</p></div></div><div class="code"><div class="wrapper">	Next() (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-close-"><em>Close</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close cursor and any associates file handles</p></div></div><div class="code"><div class="wrapper">	Close() error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-log-record-"><strong>Log Record</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogRecord describes a single item in the log file. It consists of a time, an
index id, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogRecord <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-binarymarshaler-"><em>BinaryMarshaler</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a LogRecord as a byte array</p></div></div><div class="code"><div class="wrapper">	encoding.BinaryMarshaler</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-size-"><em>Size</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the size of the record data</p></div></div><div class="code"><div class="wrapper">	Size() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-flags-"><em>Flags</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns any boolean flags associated</p></div></div><div class="code"><div class="wrapper">	Flags() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-time-"><em>Time</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time returns the record timestamp</p></div></div><div class="code"><div class="wrapper">	Time() <span class="hljs-typename">int64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-index-"><em>Index</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index returns the record offset in the log</p></div></div><div class="code"><div class="wrapper">	Index() <span class="hljs-typename">uint64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-data-"><em>Data</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns record data</p></div></div><div class="code"><div class="wrapper">	Data() []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-logrecordfactory-"><strong>LogRecordFactory</strong></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogRecordFactory generates new <code>LogRecords</code> from the arguments.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogRecordFactory <span class="hljs-keyword">func</span>(nanos <span class="hljs-typename">int64</span>, index <span class="hljs-typename">uint64</span>, flags <span class="hljs-typename">uint32</span>, data []<span class="hljs-typename">byte</span>) (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-basiclogrecordfactory-"><strong>BasicLogRecordFactory</strong></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BasicLogRecordFactory creates a v1 log record. Each record is prefixed with a header. If the record data exceeds the maximum record size, an <code>ErrRecordTooLarge</code> error is returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> BasicLogRecordFactory(maxSize <span class="hljs-typename">int</span>) LogRecordFactory {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(nanos <span class="hljs-typename">int64</span>, index <span class="hljs-typename">uint64</span>, flags <span class="hljs-typename">uint32</span>, data []<span class="hljs-typename">byte</span>) (LogRecord, error) {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt; maxSize {
			<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrRecordTooLarge
		}
		<span class="hljs-keyword">return</span> BasicLogRecord{<span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(data)), nanos, index, flags, data}, <span class="hljs-constant">nil</span>
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-basiclogrecord-"><strong>BasicLogRecord</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BasicLogRecord represents an element in the log. Each record has a timestamp, an index, boolean flags, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> BasicLogRecord <span class="hljs-keyword">struct</span> {
	size  <span class="hljs-typename">uint32</span>
	nanos <span class="hljs-typename">int64</span>
	index <span class="hljs-typename">uint64</span>
	flags <span class="hljs-typename">uint32</span>
	data  []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-time-"><em>Time</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time represents when the record was created.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Time() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> r.nanos
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-index-"><em>Index</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index is where the record lives in the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Index() <span class="hljs-typename">uint64</span> {
	<span class="hljs-keyword">return</span> r.index
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-flags-"><em>Flags</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns boolean fields associated with the record.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Flags() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.flags
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-size-"><em>Size</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the length of the record&#39;s data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Size() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.size
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-data-"><em>Data</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns the associated byte buffer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Data() []<span class="hljs-typename">byte</span> {
	<span class="hljs-keyword">return</span> r.data
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MarshalBinary encodes the entire record in a byte array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) MarshalBinary() ([]<span class="hljs-typename">byte</span>, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header buffer</p></div></div><div class="code"><div class="wrapper">	buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">24</span>+r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 size</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">0</span>, r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 flags</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">4</span>, r.flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write int64 timestamp</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutInt64(buffer, <span class="hljs-number">8</span>, r.nanos)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint64 index</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint64(buffer, <span class="hljs-number">16</span>, r.index)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write data</p></div></div><div class="code"><div class="wrapper">	buffer = <span class="hljs-built_in">append</span>(buffer[:<span class="hljs-number">24</span>], r.data...)

	<span class="hljs-keyword">return</span> buffer, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-unmarshalbasiclogrecord-"><strong>UnmarshalBasicLogRecord</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>UnmarshalBasicLogRecord is a utility method for converting a byte array to a LogRecord. If the record is too small to contain the record header, an <code>ErrInvalidRecordSize</code> error is returned. If the size outlined in the header does not equal the size of the given buffer and the header, an <code>ErrInvalidRecordSize</code> error is also returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> UnmarshalBasicLogRecord(buffer []<span class="hljs-typename">byte</span>) (*BasicLogRecord, error) {
	<span class="hljs-keyword">var</span> r BasicLogRecord
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(buffer) &lt; VersionOneLogRecordHeaderSize {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidRecordSize
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read and validate uint32 size</p></div></div><div class="code"><div class="wrapper">	size, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">if</span> size != <span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(buffer)-<span class="hljs-number">24</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidRecordSize
	}
	r.size = size</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint32 flags</p></div></div><div class="code"><div class="wrapper">	flags, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">4</span>)
	r.flags = flags</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read int64 timestamp</p></div></div><div class="code"><div class="wrapper">	nanos, _ := xbinary.LittleEndian.Int64(buffer, <span class="hljs-number">8</span>)
	r.nanos = nanos</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint64 index</p></div></div><div class="code"><div class="wrapper">	index, _ := xbinary.LittleEndian.Uint64(buffer, <span class="hljs-number">16</span>)
	r.index = index</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read data
r.data = buffer[24:]</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-built_in">copy</span>(r.data, buffer[<span class="hljs-number">24</span>:])

	<span class="hljs-keyword">return</span> &amp;r, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-version-one-log-file-"><strong>Version One Log File</strong></h2>
<p><code>versionOneLogFile</code> is obviously v1 of the WAL. It is the first class which
implements the <code>WriteAheadLog</code> interface. However, it is not a public
type. Wallaby strives to maintain a clean API and hence uses interfaces to
abstract specific implementations.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> versionOneLogFile <span class="hljs-keyword">struct</span> {
	lock        sync.Mutex
	fd          *os.File
	writeCloser io.WriteCloser
	header      FileHeader
	index       LogIndex
	factory     LogRecordFactory
	flags       <span class="hljs-typename">uint32</span>
	size        <span class="hljs-typename">int64</span>
	state       State
	hash        hash.Hash64
	nanos       <span class="hljs-typename">int64</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-open-"><em>Open</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Open</code> simply switches the state to <code>OPEN</code>. If the log is already open, the
error <code>ErrLogAlreadyOpen</code> is returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Open() error {
	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()

	<span class="hljs-keyword">if</span> v.state == OPEN {
		<span class="hljs-keyword">return</span> ErrLogAlreadyOpen
	}

	v.state = OPEN

	io.Copy(v.hash, v.fd)
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-pipe-"><em>Pipe</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Pipe</code> will read a <code>limited</code> number of the log records beginning at the
<code>offset</code> given. All the these records will be serialized into a byte array
and written to the given <code>io.Writer</code>. If there was an error either converting
the record or writing to the given <code>io.Writer</code>, the encountered error will be
returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a new record cursor, closing it when exiting the function.</p></div></div><div class="code"><div class="wrapper">	cur := v.Cursor()
	<span class="hljs-keyword">defer</span> cur.Close()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek to the given <code>offset</code> and read the records until the number of
requested records are read or an error occurs.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">for</span> record, err := cur.Seek(offset); err != <span class="hljs-constant">nil</span> &amp;&amp; record.Index() &lt; limit+offset; record, err = cur.Next() {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Marshal the record into a byte array returning the error if there
is one.</p></div></div><div class="code"><div class="wrapper">		data, e := record.MarshalBinary()
		<span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">return</span> e
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write the byte array to the given <code>writer</code> returning the error if
there is one.</p></div></div><div class="code"><div class="wrapper">		_, e = writer.Write(data)
		<span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">return</span> e
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Success. Return a <code>nil</code> error.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-state-"><em>State</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>State</code> allows the log state to be queried by returning the current state of
the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) State() State {
	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()
	<span class="hljs-keyword">return</span> v.state
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-use-"><em>Use</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Use</code> allows middleware to modify the log&#39;s behavior. <code>DecorativeWriteClosers</code>
are the vehicles which make this possible. They wrap the internal writer
with additional capabilities such as using different buffering strategies.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Use(writers ...DecorativeWriteCloser) {
	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only apply the middleware is the log is <code>CLOSED</code>. The log remains
in this state until <code>Open</code> is called.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> v.state == CLOSED {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over all the <code>DecorativeWriteClosers</code> replacing the internal
writer with the new one.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> _, writer := <span class="hljs-keyword">range</span> writers {
			v.writeCloser = writer(v.writeCloser)
		}
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-append-"><em>Append</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Append(data []<span class="hljs-typename">byte</span>) (LogRecord, error) {

	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()

	<span class="hljs-keyword">if</span> v.state != OPEN {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrLogClosed
	}

	index := v.index.Size()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create log record</p></div></div><div class="code"><div class="wrapper">	record, err := v.factory(time.Now().UnixNano(), index, v.flags, data)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrWriteLogRecord
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>binary record</p></div></div><div class="code"><div class="wrapper">	buffer, err := record.MarshalBinary()
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
	}
	v.hash.Write(buffer)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>_, err = v.fd.Write(buffer)</p></div></div><div class="code"><div class="wrapper">	v.writeCloser.Write(buffer)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
	}
	v.nanos = time.Now().UnixNano()
	v.size += <span class="hljs-typename">int64</span>(<span class="hljs-built_in">len</span>(buffer))
	v.index.Append(BasicIndexRecord{record.Time(), record.Index(), <span class="hljs-typename">int64</span>(v.size), <span class="hljs-number">0</span>})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return newly created record</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> record, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-cursor-"><em>Cursor</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Cursor() LogCursor {
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-snapshot-"><em>Snapshot</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot returns a Snapshot instance representing the current state of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Snapshot() (Snapshot, error) {
	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()
	<span class="hljs-keyword">return</span> BasicSnapshot{v.nanos, v.size, v.hash.Sum64()}, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-metadata-"><em>Metadata</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata returns information about the log file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Metadata() (Metadata, error) {
	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()

	meta := Metadata{
		Size:             v.size,
		LastModifiedTime: v.nanos,
		FileName:         v.fd.Name(),
		IndexFileName:    v.fd.Name() + <span class="hljs-string">".idx"</span>,
	}
	<span class="hljs-keyword">return</span> meta, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-recover-"><em>Recover</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Recover() error {
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="close">Close</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Close</code> changes the log state to <code>CLOSED</code>. The <code>io.WriterCloser</code> as well as
the underlying file should not recieve any writes after this call has
completed. <code>Append</code> will return an <code>ErrLogClosed</code> after this method is
called.</p>
<h5 id="implementation">Implementation</h5></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Close() error {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The log is locked before closing the file. The log is then
unlocked on return. After the log has been locked the state is set to
<code>CLOSED</code>.</p></div></div><div class="code"><div class="wrapper">	v.lock.Lock()
	<span class="hljs-keyword">defer</span> v.lock.Unlock()

	v.state = CLOSED</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally, the record <code>io.WriteCloser</code> is closed. The <code>DecorativeWriteCloser</code>
is expected to flush all the remaining data. If there is an error during
close, the error bubbles up.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> v.writeCloser.Close()
}</div></div></div></div></body></html>