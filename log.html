<!DOCTYPE html><html lang="en"><head><title>log</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="log"><meta name="groc-project-path" content="log.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/log.go">log.go</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"io"</span>

	<span class="hljs-string">"github.com/eliquious/xbinary"</span>
)

<span class="hljs-keyword">var</span> (
	ErrRecordTooLarge = errors.New(<span class="hljs-string">"record is too large"</span>)

	ErrInvalidRecordSize = errors.New(<span class="hljs-string">"invalid record size"</span>)
)

<span class="hljs-keyword">const</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DefaultRecordFlags represents the default boolean flags for each log record.</p></div></div><div class="code"><div class="wrapper">	DefaultRecordFlags <span class="hljs-typename">uint32</span> = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DefaultMaxRecordSize is the default maximum size of a log record.</p></div></div><div class="code"><div class="wrapper">	DefaultMaxRecordSize = <span class="hljs-number">0xffff</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State is used to maintain the current status of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> State <span class="hljs-typename">uint8</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>CLOSED represents a closed log file</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> CLOSED State = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>OPEN signifies the log is currently open</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> OPEN State = <span class="hljs-number">1</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>WriteAheadLog implements an immutable write-ahead log file with indexes and
snapshots.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> WriteAheadLog <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Closer allows the log to be closed</p></div></div><div class="code"><div class="wrapper">	io.Closer</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new record and appends it to the log.</p></div></div><div class="code"><div class="wrapper">	Appender</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recoverable allows the log to be recovered upon crash</p></div></div><div class="code"><div class="wrapper">	Recoverable</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cursable allows cursors to be created.</p></div></div><div class="code"><div class="wrapper">	Cursable</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stateful allows the state of the log to be retrieved.</p></div></div><div class="code"><div class="wrapper">	Stateful</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Opener opens the log for appending. Prior to this call the log state
should be CLOSED. Once this is called State() should return OPEN.</p></div></div><div class="code"><div class="wrapper">	Opener</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use provides middleware for the internal io.Writer</p></div></div><div class="code"><div class="wrapper">	Use(...DecorativeWriteCloser)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Piper allows log records to be transferred to another writer.</p></div></div><div class="code"><div class="wrapper">	Piper</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot records the current position of the log file.</p></div></div><div class="code"><div class="wrapper">	Snapshot() (Snapshot, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata returns meta data of the log file.</p></div></div><div class="code"><div class="wrapper">	Metadata() (Metadata, error)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DecorativeWriteCloser allows for middleware around the internal file writer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> DecorativeWriteCloser <span class="hljs-keyword">func</span>(io.WriteCloser) io.WriteCloser</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Opener is the interface for Open. Open makes the log available for writing.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Opener <span class="hljs-keyword">interface</span> {
	Open() error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stateful is the interface for the State method. State returns the current
state of the log file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Stateful <span class="hljs-keyword">interface</span> {
	State() State
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recoverable is the interface which wraps the Recover method. Recover should
return the log to a stable state.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Recoverable <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recover should be called when the log is opened to verify consistency
of the log.</p></div></div><div class="code"><div class="wrapper">	Recover() error
}

<span class="hljs-keyword">type</span> Cursable <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new Cursor initialized at index 0</p></div></div><div class="code"><div class="wrapper">	Cursor() Cursor
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Appender appends a new record to the end of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Appender <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Append wraps the given bytes array in a Record and returns the record
index or an error</p></div></div><div class="code"><div class="wrapper">	Append(data []<span class="hljs-typename">byte</span>) (LogRecord, error)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cursor allows for quite navigation through the log. All Cursor start at zero
 and moves forward until EOF.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Cursor <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek moves the Cursor to the given record index.</p></div></div><div class="code"><div class="wrapper">	Seek(offset <span class="hljs-typename">uint64</span>) (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next moves the Cursor forward one record.</p></div></div><div class="code"><div class="wrapper">	Next() (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close cursor and any associates file handles</p></div></div><div class="code"><div class="wrapper">	Close() error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Piper copies the raw byte stream into the given io.Writer starting at a
record offset and reading up until the given limit.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> Piper <span class="hljs-keyword">interface</span> {
	Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogHeader is at the front of the log file and describes which version the
file was written with as well as any boolean flags associated with the file</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogHeader <span class="hljs-keyword">interface</span> {
	Version() <span class="hljs-typename">uint8</span>
	Flags() <span class="hljs-typename">uint32</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogRecord describes a single item in the log file. It consists of a time, an
index id, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogRecord <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns LogRecord as a byte array</p></div></div><div class="code"><div class="wrapper">	encoding.BinaryMarshaler</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a byte array into a LogRecord</p></div></div><div class="code"><div class="wrapper">	encoding.BinaryUnmarshaler</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the size of the record data</p></div></div><div class="code"><div class="wrapper">	Size() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns any boolean flags associated</p></div></div><div class="code"><div class="wrapper">	Flags() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time returns the record timestamp</p></div></div><div class="code"><div class="wrapper">	Time() <span class="hljs-typename">int64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index returns the record offset in the log</p></div></div><div class="code"><div class="wrapper">	Index() <span class="hljs-typename">uint64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns record data</p></div></div><div class="code"><div class="wrapper">	Data() []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneLogRecordFactory generates log records.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> VersionOneLogRecordFactory <span class="hljs-keyword">struct</span> {
	MaxRecordSize <span class="hljs-typename">int</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NewRecord creates a v1 log record. Each record is prefixed with a header of
20 bytes. It consists of an int64 timestamp (nanoseconds unixtime), the
record index (uint64), boolean flags, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (f *VersionOneLogRecordFactory) NewRecord(nanos <span class="hljs-typename">int64</span>, index <span class="hljs-typename">uint64</span>, flags <span class="hljs-typename">uint32</span>, data []<span class="hljs-typename">byte</span>) (LogRecord, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>checks if record is too large</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt; f.MaxRecordSize {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrRecordTooLarge
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return new log record</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> VersionOneLogRecord{<span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(data)), nanos, index, flags, data}, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VersionOneLogRecord represents an element in the log. Each record has a
timestamp, an index, boolean flags, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> VersionOneLogRecord <span class="hljs-keyword">struct</span> {
	size  <span class="hljs-typename">uint32</span>
	nanos <span class="hljs-typename">int64</span>
	index <span class="hljs-typename">uint64</span>
	flags <span class="hljs-typename">uint32</span>
	data  []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time represents when the record was created.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) Time() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> r.nanos
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index is where the record lives in the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) Index() <span class="hljs-typename">uint64</span> {
	<span class="hljs-keyword">return</span> r.index
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns boolean fields associated with the record.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) Flags() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.flags
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the length of the record&#39;s data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) Size() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.size
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns the associated byte buffer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) Data() []<span class="hljs-typename">byte</span> {
	<span class="hljs-keyword">return</span> r.data
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MarshalBinary encodes the entire record in a byte array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r VersionOneLogRecord) MarshalBinary() ([]<span class="hljs-typename">byte</span>, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header buffer</p></div></div><div class="code"><div class="wrapper">	buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">24</span>+r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 size</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">0</span>, r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 flags</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">4</span>, r.flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write int64 timestamp</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutInt64(buffer, <span class="hljs-number">8</span>, r.nanos)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint64 index</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint64(buffer, <span class="hljs-number">16</span>, r.index)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write data</p></div></div><div class="code"><div class="wrapper">	buffer = <span class="hljs-built_in">append</span>(buffer[:<span class="hljs-number">24</span>], r.data...)

	<span class="hljs-keyword">return</span> buffer, <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> (r VersionOneLogRecord) UnmarshalBinary(buffer []<span class="hljs-typename">byte</span>) error {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(buffer) &lt; <span class="hljs-number">24</span> {
		<span class="hljs-keyword">return</span> ErrInvalidRecordSize
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read and validate uint32 size</p></div></div><div class="code"><div class="wrapper">	size, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">if</span> size != <span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(buffer)-<span class="hljs-number">24</span>) {
		<span class="hljs-keyword">return</span> ErrInvalidRecordSize
	}
	r.size = size</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint32 flags</p></div></div><div class="code"><div class="wrapper">	flags, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">4</span>)
	r.flags = flags</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read int64 timestamp</p></div></div><div class="code"><div class="wrapper">	nanos, _ := xbinary.LittleEndian.Int64(buffer, <span class="hljs-number">8</span>)
	r.nanos = nanos</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint64 index</p></div></div><div class="code"><div class="wrapper">	index, _ := xbinary.LittleEndian.Uint64(buffer, <span class="hljs-number">16</span>)
	r.index = index</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read data</p></div></div><div class="code"><div class="wrapper">	r.data = buffer[<span class="hljs-number">24</span>:]

	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div></div></body></html>