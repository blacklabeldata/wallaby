<!DOCTYPE html><html lang="en"><head><title>log</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="log"><meta name="groc-project-path" content="log.go"><meta name="groc-github-url" content="https://github.com/eliquious/wallaby"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/eliquious/wallaby/blob/master/log.go">log.go</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="log-implementations">Log Implementations</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> wallaby

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding"</span>
	<span class="hljs-string">"hash"</span>
	<span class="hljs-string">"io"</span>
	<span class="hljs-string">"os"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"github.com/eliquious/xbinary"</span>
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-log-state-"><strong>Log State</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State is used to maintain the current status of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> State <span class="hljs-typename">uint8</span>

<span class="hljs-keyword">const</span> UNOPENED State = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>OPEN</code> signifies the log is currently open</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> OPEN State = <span class="hljs-number">1</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>CLOSED</code> represents a closed log file</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> CLOSED State = <span class="hljs-number">2</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><br/></p>
<h2 id="-log-interfaces-"><strong>Log Interfaces</strong></h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-write-ahead-log-"><strong>Write Ahead Log</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>WriteAheadLog implements an immutable write-ahead log file with indexes and
snapshots.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> WriteAheadLog <span class="hljs-keyword">interface</span> {
	io.WriteCloser</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-state-"><em>State</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>State</code> returns the current state of the log file.</p></div></div><div class="code"><div class="wrapper">	State() State</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-open-"><em>Open</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Open</code> opens the log for appending. Prior to this call the log state
should be CLOSED. Once this is called State() should return OPEN.</p></div></div><div class="code"><div class="wrapper">	Open() error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-recover-"><em>Recover</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recover should be called when the log is opened to verify consistency
of the log.</p></div></div><div class="code"><div class="wrapper">	Recover() error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-cursor-"><em>Cursor</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new Cursor initialized at index 0</p></div></div><div class="code"><div class="wrapper">	Cursor() LogCursor</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-use-"><em>Use</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use provides middleware for the internal <code>io.WriteCloser</code></p></div></div><div class="code"><div class="wrapper">	Use(...DecorativeWriteCloser)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-pipe-"><em>Pipe</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pipe copies the raw byte stream into the given <code>io.Writer</code> starting at a
record offset and reading up until the given limit.</p></div></div><div class="code"><div class="wrapper">	Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-snapshot-"><em>Snapshot</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot records the current position of the log file.</p></div></div><div class="code"><div class="wrapper">	Snapshot() (Snapshot, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-metadata-"><em>Metadata</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata returns metadata of the log file.</p></div></div><div class="code"><div class="wrapper">	Metadata() (Metadata, error)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-log-cursor-"><strong>Log Cursor</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogCursor allows for quite navigation through the log. All Cursor start at zero
 and moves forward until EOF.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogCursor <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-seek-"><em>Seek</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek moves the Cursor to the given record index.</p></div></div><div class="code"><div class="wrapper">	Seek(offset <span class="hljs-typename">uint64</span>) (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-next-"><em>Next</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next moves the Cursor forward one record.</p></div></div><div class="code"><div class="wrapper">	Next() (LogRecord, error)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-close-"><em>Close</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Close cursor and any associates file handles</p></div></div><div class="code"><div class="wrapper">	Close() error
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-log-record-"><strong>Log Record</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LogRecord describes a single item in the log file. It consists of a time, an
index id, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> LogRecord <span class="hljs-keyword">interface</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-binarymarshaler-"><em>BinaryMarshaler</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a LogRecord as a byte array</p></div></div><div class="code"><div class="wrapper">	encoding.BinaryMarshaler</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-size-"><em>Size</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the size of the record data</p></div></div><div class="code"><div class="wrapper">	Size() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-flags-"><em>Flags</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns any boolean flags associated</p></div></div><div class="code"><div class="wrapper">	Flags() <span class="hljs-typename">uint32</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-time-"><em>Time</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time returns the record timestamp</p></div></div><div class="code"><div class="wrapper">	Time() <span class="hljs-typename">int64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-index-"><em>Index</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index returns the record offset in the log</p></div></div><div class="code"><div class="wrapper">	Index() <span class="hljs-typename">uint64</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-data-"><em>Data</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns record data</p></div></div><div class="code"><div class="wrapper">	Data() []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-logrecordfactory-"><strong>LogRecordFactory</strong></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>func NewRecordWriter(maxSize int, startingIndex uint64, flags uint32, writer io.WriteCloser) io.WriteCloser {
    return v1LogRecordFactory{maxSize, 0, 0, make([]byte, 0, maxSize+24), writer}</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">// </span>

<span class="hljs-keyword">type</span> v1LogRecordFactory <span class="hljs-keyword">struct</span> {
	maxSize <span class="hljs-typename">int</span>
	index   <span class="hljs-typename">uint64</span>
	flags   <span class="hljs-typename">uint32</span>
	buffer  []<span class="hljs-typename">byte</span>
	parent  io.WriteCloser
}

<span class="hljs-keyword">func</span> (b v1LogRecordFactory) Write(data []<span class="hljs-typename">byte</span>) (<span class="hljs-typename">int</span>, error) {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt; b.maxSize {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrRecordTooLarge
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 size</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(data, <span class="hljs-number">0</span>, <span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(data)))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 flags</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(data, <span class="hljs-number">4</span>, b.flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write int64 timestamp</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutInt64(data, <span class="hljs-number">8</span>, time.Now().UnixNano())</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint64 index</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint64(data, <span class="hljs-number">16</span>, b.index)
	b.index++

	<span class="hljs-built_in">copy</span>(b.buffer[<span class="hljs-number">24</span>:<span class="hljs-built_in">len</span>(data)+<span class="hljs-number">24</span>], data[:])

	<span class="hljs-keyword">return</span> b.parent.Write(b.buffer[:<span class="hljs-built_in">len</span>(data)+<span class="hljs-number">24</span>])
}

<span class="hljs-keyword">func</span> (b v1LogRecordFactory) Close() error {
	<span class="hljs-keyword">return</span> b.parent.Close()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-basiclogrecord-"><strong>BasicLogRecord</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BasicLogRecord represents an element in the log. Each record has a timestamp, an index, boolean flags, a length and the data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> BasicLogRecord <span class="hljs-keyword">struct</span> {
	size  <span class="hljs-typename">uint32</span>
	nanos <span class="hljs-typename">int64</span>
	index <span class="hljs-typename">uint64</span>
	flags <span class="hljs-typename">uint32</span>
	data  []<span class="hljs-typename">byte</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-time-"><em>Time</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Time represents when the record was created.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Time() <span class="hljs-typename">int64</span> {
	<span class="hljs-keyword">return</span> r.nanos
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-index-"><em>Index</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index is where the record lives in the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Index() <span class="hljs-typename">uint64</span> {
	<span class="hljs-keyword">return</span> r.index
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-flags-"><em>Flags</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flags returns boolean fields associated with the record.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Flags() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.flags
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-size-"><em>Size</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size returns the length of the record&#39;s data.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Size() <span class="hljs-typename">uint32</span> {
	<span class="hljs-keyword">return</span> r.size
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-data-"><em>Data</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data returns the associated byte buffer.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) Data() []<span class="hljs-typename">byte</span> {
	<span class="hljs-keyword">return</span> r.data
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MarshalBinary encodes the entire record in a byte array.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (r BasicLogRecord) MarshalBinary() ([]<span class="hljs-typename">byte</span>, error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create header buffer</p></div></div><div class="code"><div class="wrapper">	buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">24</span>+r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 size</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">0</span>, r.size)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint32 flags</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint32(buffer, <span class="hljs-number">4</span>, r.flags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write int64 timestamp</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutInt64(buffer, <span class="hljs-number">8</span>, r.nanos)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write uint64 index</p></div></div><div class="code"><div class="wrapper">	xbinary.LittleEndian.PutUint64(buffer, <span class="hljs-number">16</span>, r.index)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>write data</p></div></div><div class="code"><div class="wrapper">	buffer = <span class="hljs-built_in">append</span>(buffer[:<span class="hljs-number">24</span>], r.data...)

	<span class="hljs-keyword">return</span> buffer, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="-unmarshalbasiclogrecord-"><strong>UnmarshalBasicLogRecord</strong></h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>UnmarshalBasicLogRecord is a utility method for converting a byte array to a LogRecord. If the record is too small to contain the record header, an <code>ErrInvalidRecordSize</code> error is returned. If the size outlined in the header does not equal the size of the given buffer and the header, an <code>ErrInvalidRecordSize</code> error is also returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> UnmarshalBasicLogRecord(buffer []<span class="hljs-typename">byte</span>) (*BasicLogRecord, error) {
	<span class="hljs-keyword">var</span> r BasicLogRecord
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(buffer) &lt; VersionOneLogRecordHeaderSize {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidRecordSize
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read and validate uint32 size</p></div></div><div class="code"><div class="wrapper">	size, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">if</span> size != <span class="hljs-typename">uint32</span>(<span class="hljs-built_in">len</span>(buffer)-<span class="hljs-number">24</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, ErrInvalidRecordSize
	}
	r.size = size</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint32 flags</p></div></div><div class="code"><div class="wrapper">	flags, _ := xbinary.LittleEndian.Uint32(buffer, <span class="hljs-number">4</span>)
	r.flags = flags</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read int64 timestamp</p></div></div><div class="code"><div class="wrapper">	nanos, _ := xbinary.LittleEndian.Int64(buffer, <span class="hljs-number">8</span>)
	r.nanos = nanos</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read uint64 index</p></div></div><div class="code"><div class="wrapper">	index, _ := xbinary.LittleEndian.Uint64(buffer, <span class="hljs-number">16</span>)
	r.index = index</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>read data
r.data = buffer[24:]</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-built_in">copy</span>(r.data, buffer[<span class="hljs-number">24</span>:])

	<span class="hljs-keyword">return</span> &amp;r, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-version-one-log-file-"><strong>Version One Log File</strong></h2>
<p><code>versionOneLogFile</code> is obviously v1 of the WAL. It is the first class which
implements the <code>WriteAheadLog</code> interface. However, it is not a public
type. Wallaby strives to maintain a clean API and hence uses interfaces to
abstract specific implementations.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">type</span> versionOneLogFile <span class="hljs-keyword">struct</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>lock        sync.Mutex</p></div></div><div class="code"><div class="wrapper">	fd            *os.File
	writeCloser   io.WriteCloser
	config        Config
	header        FileHeader
	index         LogIndex
	size          <span class="hljs-typename">int64</span>
	state         State
	hash          hash.Hash64
	indexBuffer   []<span class="hljs-typename">byte</span>
	ttl           <span class="hljs-typename">int64</span>
	lastWriteTime <span class="hljs-typename">int64</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-open-"><em>Open</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Open</code> simply switches the state to <code>OPEN</code>. If the log is already open, the
error <code>ErrLogAlreadyOpen</code> is returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Open() error {
	v.Use(<span class="hljs-keyword">func</span>(writer io.WriteCloser) io.WriteCloser {
		<span class="hljs-keyword">return</span> v1LogRecordFactory{v.config.MaxRecordSize, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">0</span>, v.config.MaxRecordSize+VersionOneLogRecordHeaderSize), writer}

	})

	<span class="hljs-keyword">if</span> v.state == OPEN {
		<span class="hljs-keyword">return</span> ErrLogAlreadyOpen
	}

	v.state = OPEN

	io.Copy(v.hash, v.fd)
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-state-"><em>State</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>State</code> allows the log state to be queried by returning the current state of
the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) State() State {
	<span class="hljs-keyword">return</span> v.state
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-use-"><em>Use</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Use</code> allows middleware to modify the log&#39;s behavior. <code>DecorativeWriteClosers</code>
are the vehicles which make this possible. They wrap the internal writer
with additional capabilities such as using different buffering strategies.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Use(writers ...DecorativeWriteCloser) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only apply the middleware is the log is <code>CLOSED</code>. The log remains
in this state until <code>Open</code> is called.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> v.state == UNOPENED {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over all the <code>DecorativeWriteClosers</code> replacing the internal
writer with the new one.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> _, writer := <span class="hljs-keyword">range</span> writers {
			v.writeCloser = writer(v.writeCloser)
		}
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-append-"><em>Append</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Write(data []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the log is not <code>OPEN</code>, return error</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> v.state != OPEN {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrLogClosed
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update log checksum</p></div></div><div class="code"><div class="wrapper">	v.hash.Write(data)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write data into file</p></div></div><div class="code"><div class="wrapper">	n, err = v.writeCloser.Write(data)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span>
	}
	v.size += <span class="hljs-typename">int64</span>(n)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copy <code>timestamp</code> and <code>index</code> from log record into index buffer</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-built_in">copy</span>(v.indexBuffer[:<span class="hljs-number">16</span>], data[<span class="hljs-number">8</span>:])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set lastWriteTime</p></div></div><div class="code"><div class="wrapper">	lastWriteTime, err := xbinary.LittleEndian.Int64(data, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span>
	}
	v.lastWriteTime = lastWriteTime</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write file offset data into index buffer</p></div></div><div class="code"><div class="wrapper">	_, err = xbinary.LittleEndian.PutInt64(v.indexBuffer, <span class="hljs-number">16</span>, v.size)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span>
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write ttl into index buffer</p></div></div><div class="code"><div class="wrapper">	_, err = xbinary.LittleEndian.PutInt64(v.indexBuffer, <span class="hljs-number">24</span>, v.ttl)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span>
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write index record into log index</p></div></div><div class="code"><div class="wrapper">	v.index.Write(v.indexBuffer)

	<span class="hljs-keyword">return</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-cursor-"><em>Cursor</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Cursor() LogCursor {
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-snapshot-"><em>Snapshot</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Snapshot returns a Snapshot instance representing the current state of the log.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Snapshot() (Snapshot, error) {
	<span class="hljs-keyword">return</span> BasicSnapshot{v.lastWriteTime, v.size, v.hash.Sum64()}, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-metadata-"><em>Metadata</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Metadata returns information about the log file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Metadata() (Metadata, error) {

	meta := Metadata{
		Size:             v.size,
		LastModifiedTime: v.lastWriteTime,
		FileName:         v.fd.Name(),
		IndexFileName:    v.fd.Name() + <span class="hljs-string">".idx"</span>,
	}
	<span class="hljs-keyword">return</span> meta, <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-recover-"><em>Recover</em></h6></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Recover() error {
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="close">Close</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Close</code> changes the log state to <code>CLOSED</code>. The <code>io.WriterCloser</code> as well as
the underlying file should not recieve any writes after this call has
completed. <code>Append</code> will return an <code>ErrLogClosed</code> after this method is
called.</p>
<h5 id="implementation">Implementation</h5></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Close() error {
	v.state = CLOSED</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally, the record <code>io.WriteCloser</code> is closed. The <code>DecorativeWriteCloser</code>
is expected to flush all the remaining data. If there is an error during
close, the error bubbles up.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> v.writeCloser.Close()
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="-pipe-"><em>Pipe</em></h6></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Pipe</code> will read a <code>limited</code> number of the log records beginning at the
<code>offset</code> given. All the these records will be serialized into a byte array
and written to the given <code>io.Writer</code>. If there was an error either converting
the record or writing to the given <code>io.Writer</code>, the encountered error will be
returned.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">func</span> (v *versionOneLogFile) Pipe(offset, limit <span class="hljs-typename">uint64</span>, writer io.Writer) error {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a new record cursor, closing it when exiting the function.</p></div></div><div class="code"><div class="wrapper">	cur := v.Cursor()
	<span class="hljs-keyword">defer</span> cur.Close()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek to the given <code>offset</code> and read the records until the number of
requested records are read or an error occurs.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">for</span> record, err := cur.Seek(offset); err != <span class="hljs-constant">nil</span> &amp;&amp; record.Index() &lt; limit+offset; record, err = cur.Next() {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Marshal the record into a byte array returning the error if there
is one.</p></div></div><div class="code"><div class="wrapper">		data, e := record.MarshalBinary()
		<span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">return</span> e
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Write the byte array to the given <code>writer</code> returning the error if
there is one.</p></div></div><div class="code"><div class="wrapper">		_, e = writer.Write(data)
		<span class="hljs-keyword">if</span> e != <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">return</span> e
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Success. Return a <code>nil</code> error.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</div></div></div></div></body></html>